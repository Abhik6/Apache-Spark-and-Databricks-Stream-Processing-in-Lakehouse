Welcome Back.

We created our setup script in the earlier lecture.

Now it's time to explain the code and help you understand the unit testing approach for the setup.

So let me go back to my workspace.

Here it is.

Go to workspace

Repos

and select your SBIT repository.

Great!

I can see two notebooks here.

Config and Setup.

Let me open the Config Notebook and explain the code.

I have a super small configuration code.

The idea is to create a notebook to keep all my project configurations.

So I am creating a Config class and defining 4 configuration variables.

The first one is the directory location of the data zone.

I do not want to hardcode the directory location of the data zone.

So I am extracting the URL from the data zone external location definition

and keeping it in a configuration variable.

I will use the variable instead of using the directory location.

This approach is good practice to avoid hard coding physical locations in your application.

How do we take the directory name?

Well! I am executing a describe SQL command to get the actual physical location.

Simple!

Isn't it?

Similarly, I am taking out the checkpoint location and creating a variable.

I am also creating a variable for the database name.

In an ideal case, we should be creating three databases.

One for bronze, one for silver, and a gold database.

That's how I designed my application.

Correct?

But for simplicity, I will create only one database and use the same one for bronze, silver, and gold tables.

Creating a separate database is recommended

when you have many tables in each layer of medallion architecture.

But this project is small, so let's keep it simple and a single database.

I do not want to hardcode the database name, so I create a variable in the config class.

That's all.

You might see some other configuration variables here, but I will explain them when we use them.

Great!

I hope you learned some best practices here.

Let me highlight.

Centralize your configurations in one place.

The best practice is to create one Config class where you can keep all your configurations.

Avoid hardcoding physical locations, names, and values as much as possible.

Great!

Now let me jump to the setup notebook and quickly explain it.

Click this small directory icon adjacent to the notebook code.

You can see all your notebooks.

Choose the setup notebook, and you can see the code.

Great!

What am I doing in my setup script?

I am importing the config notebook at the top.

Why?

Because I want to use the config class.

I am also creating a SetupHelper class.

The idea is to wrap all my setup-related functions into a setup class.

Let's look at the functions.

The __init__ function is the class constructor.

I am initializing some variables in the constructor.

The constructor takes the environment name argument.

And this approach allows me to use the same code in dev, QA, and prod environments.

All I have to do is to pass the correct environment name, and the same code works in all the environments.

Parameterizing the environment is a typical requirement in almost every project.

Why?

Because we do not want to change the code when we want to run it in a different environment.

Great!

The next one is the create_db function.

This function executes the CREATE DATABASE DDL.

The code is simple, and I hope you understand that.

The next one is the create_registered_users function.

This function executes CREATE TABLE DDL to create a registered_users table.

Similarly, I defined one function for each table.

Scroll down,

and you will see the create_gym_logins function.

This guy creates a gym_logins table.

Then we have create_kafka_multiplex function,

create_users function,

create_gym_logs,

create_user_profile

create_heart_rate

create_user_bins

create_workouts

create_completed_workouts

create_workout_bpm

create_date_lookup

create_workout_bpm_summary

and create_gym_summary.

That's all about creating tables.

The approach is simple.

Create one function to execute the CREATE TABLE DDL for each table.

Finally, I defined one setup function.

This function basically calls all the DDL functions.

So instead of calling all the functions individually,

I can call a single setup function to create the database and all other tables.

I have also written two functions for validation.

The first one is to assert a table.

I can call this function to check if the table is successfully created.

The validate function does all the validation.

The idea is to call the setup function for creating all the tables.

Then we can call the validate function to verify if all the tables are created successfully.

That's our unit testing approach for the DDLs.

Finally, I have also written a cleanup function.

The cleanup function is to drop the database and all the tables and delete all the intermediate data directories.

And that is all about the initial setup.

We have a lot going on in this notebook.

And I leave you to go through the code and learn the approach.

Careful study of the code is precious, giving you an idea of how to implement setup in your projects.

Great!

Now it's time to test this code and see If I have done everything correctly.

Let's do it.

For executing the code, you need a cluster.

So let me go to the Compute menu and create a new cluster.

I will go with a single-node Cluster.

Do not use the photon accelerator.

Also, terminate this cluster after 30 minutes of inactivity.

You can double-check the DBUs per hour for this cluster.

I am paying 0.75 DBU per hour for running this cluster.

And that's the bare minimum.

Let me create the cluster.

While the cluster is starting, let me go to the workspace menu.

Expand the workspace

Users.

You can see your user name here.

Right-click the username and create a new notebook.

Let's name this notebook as a scratchpad.

Great!

So I created a scratchpad notebook in my local workspace.

This notebook is not under the repos.

Why?

Because I do not want to commit this notebook to my project.

I will write code to run and test my setup.

If everything is working fine, I can commit to the setup notebook.

If I see errors, I can fix them and try testing them again.

The scratchpad notebook remains in my local workspace, and I will delete it later.

I do not want to add the scratchpad notebook to my project,

so I created it in my workspace instead of in the SBIT repo.

Great!

Let me write some code to test my setup script.

The first step is to import the setup script.

Let me run it.

Works.

Go to the next cell and create an instance of the setup helper class.

Before I run the setup, let me run the cleanup method.

Good.

So I am creating the setup helper object and running the cleanup method.

Let me run it.

Worked!

And you can see the output messages.

Go to the next cell and run the setup method.

Worked.

And you can see all the success messages.

Now let's unit test the setup.

Go to the next cell and run the validate method.

Great!

This one also worked.

So my validation is also complete.

So everything is working as expected.

You can clean up again to remove everything we created using the setup.

Let me do it in the next cell.

Done.

Great!

And that's all about the setup.

So what did you learn?

We learned to create a setup script for our project.

The setup script will create the database, and tables,

validate everything and have a cleanup function so I can do the cleanup as and when needed.

We also learned how to test your code.

I have already committed my setup and config scripts to the source control, so that step is unnecessary.

Don't forget to delete your cluster.

If you keep it running, you will incur some costs.

So go ahead and delete your cluster.

You can spin up a new cluster later.

Your code is anyway saved in your repository and local workspace.

Deleting the cluster will not remove your code and data.

Great!

See you again.

Keep Learning and Keep growing.
