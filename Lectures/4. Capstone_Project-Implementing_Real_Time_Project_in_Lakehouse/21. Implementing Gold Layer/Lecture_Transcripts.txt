Welcome Back.

We coded our silver layer process.

Now, it's time to code our gold layer.

So, before we start, let me show you the data flow diagram.

Here it is.

Just look at it, you know you have many silver-layer tables.

However, you have only two gold-layer tables.

Each of these two gold-layer tables is based on the two silver-layer tables.

In the gold layer, we need to write functions that read data from the silver layer and fill the gold layer tables.

So, we need to code all the yellow lines in this diagram.

Correct?

However, you can also create the gold layer reports using views.

Creating a gold layer table and filling it with a pipeline from the silver layer is not always necessary.

We can directly create a view on the silver layer tables and expose it for gold layer reporting.

In our example, we have two gold-layer tables.

I have already implemented the gym summary as a view.

The setup module already includes the code for defining and creating a view.

You can refer to the setup module code for the same.

In our gold layer, we will create a function to fill the workout bpm summary.

Great!

Let me go to my dev environment and create a new notebook for the gold layer.

Go to Workspace

Repos and choose your SBIT repository.

Now, you can add a new notebook here.

Rename the notebook.

We are now ready to code.

Let me import the config notebook.

I will paste some code for an Upserter class in the second cell.

This code is similar to the silver layer upserter.

So, I am not going to explain it again.

Finally, Let me paste the code for the Gold class.

This one is our Gold layer code.

Let me quickly walk you through the code.

The code structure and processing logic are similar to some silver-layer tables.

So you can understand the code and learn what is happening.

But let me walk you.

The __init__ method is a constructor for the class.

I am setting up some variables in this method.

After that, I have one function for the target gold layer table.

The upsert_workout_bpm_summary method will merge the data into the workout_bpm_summary table.

I have only one target in the gold layer, so I created only one function here.

The approach is similar to the silver layer.

I am using the readStream method to read the data from the workout_bpm table.

I am also reading user_bins above as a dataframe.

Then I join the user_bins dataframe with my streaming dataframe.

We are applying the necessary aggregations and transformations on our streaming data frame.

And finally, I will send the transformed dataframe to the foreachBatch() method.

The foreachBatch will call the upsert method, and I will merge the dataframe into the target.

We used the same technique for the silver layer.

The gold layer processing approach is also the same.

The rest of the code in the gold class is straightforward.

I have a standard upsert method to trigger all the gold layer methods.

Then, I have assert_count and assert_rows functions to be used in validation.

Finally, I have a validated method for testing my gold layer.

And that is all.

I want to highlight one last thing.

Look at the assert_rows method.

We are creating the expected_rows dataframe reading a parquet file.

Next, we create an actual_rows dataframe reading our gold layer table.

Finally, we assert that the expected rows must equal the actual ones.

What does it mean?

We are not performing only the count validation.

We are performing a record-by-record comparison.

I already prepared the expected results and saved it as a parquet file.

I am comparing the gold layer table with the expected results from the parquet file.

This type of validation is more exhaustive

because we are comparing the complete result and not only the row count.

Great!

That's all about the gold layer.

We finished coding the bronze, silver, and gold layers.

See you in the following lecture.

Keep Learning and Keep Growing.
